---
description: 로컬 이미지 메타데이터 제거 및 변형 도구 - Python + PySide6 기반 크로스 플랫폼 데스크톱 앱
thumbnail: /images/portfolio/image-setakgi-thumb.jpg
github: https://github.com/ganggyunggyu/image-setakgi-py-app
demo: ''
featured: true
period: '2024.11 ~ 현재'
role: '1인 개발 (기획, 설계, 개발, 테스트)'
---

# Image Setakgi - 이미지 세탁기

## 프로젝트 배경

웹에서 이미지 메타데이터 제거 서비스를 사용하고 있었는데, 파일을 업로드하는 게 귀찮고 느려서 로컬에서 동작하는 프로그램을 만들기로 했습니다. 단순히 메타데이터만 지우는 게 아니라, 회전, 노이즈 추가, 원근 변형 등 이미지 자체를 변형해서 역추적을 어렵게 만드는 게 목표였습니다.

---

## 주요 기능 (간략)

- **일괄 이미지 변형**: 드래그앤드롭으로 여러 파일 처리
- **실시간 미리보기**: 옵션 변경 시 즉시 반영 (별도 스레드)
- **이미지 변환**: 회전, 크롭, 원근 변형, 노이즈 추가, 색조 조정
- **메타데이터 조작**: EXIF 삭제 또는 랜덤 생성
- **멀티스레드 처리**: 100개 파일도 빠르게 처리

**기술 스택**: Python 3.10, PySide6, Pillow, NumPy, PyInstaller

---

## 기술적 도전과제

### 1. 회전 후 빈 공간 자동 제거

**문제 상황**

이미지를 회전시키면 모서리에 빈 공간(삼각형 영역)이 생깁니다. 투명 배경으로 남겨두면 JPEG로 저장할 때 흰색이 되고, 사용자가 일일이 크롭해야 하는 불편함이 있었습니다.

**해결 방법**

회전 후 빈 공간이 전혀 없는 최대 크기의 내접 직사각형을 수학적으로 계산하는 알고리즘을 구현했습니다.

#### 알고리즘 ([image_ops.py:8-38](app/core/image_ops.py#L8-L38))

```python
def get_inscribed_rect_size(orig_w: int, orig_h: int, angle_deg: float):
    """회전 후 빈 공간 없이 추출 가능한 최대 직사각형 크기 계산"""
    angle = math.radians(abs(angle_deg))
    cos_a = abs(math.cos(angle))
    sin_a = abs(math.sin(angle))

    # cos(2θ) = cos²θ - sin²θ (제곱근 연산 회피)
    cos_2a = cos_a * cos_a - sin_a * sin_a

    # 45도 특수 케이스 처리
    if abs(cos_2a) < 1e-10:
        scale = 1 / math.sqrt(2)
        return int(orig_w * scale), int(orig_h * scale)

    # 원본 비율 유지하는 최대 내접 직사각형
    if orig_w * sin_a >= orig_h * cos_a:
        new_w = (orig_w * cos_a - orig_h * sin_a) / cos_2a
        new_h = new_w * orig_h / orig_w
    else:
        new_h = (orig_h * cos_a - orig_w * sin_a) / cos_2a
        new_w = new_h * orig_w / orig_h

    return max(10, int(new_w)), max(10, int(new_h))
```

**핵심 아이디어**

- 삼각함수 항등식(`cos(2θ) = cos²θ - sin²θ`)을 활용해 제곱근 연산 최소화
- 시간 복잡도: **O(1)** (순수 수학 연산만 사용)
- 45도 같은 특수 각도는 분기 처리해서 정밀도 향상

**적용 결과**

1. 이미지 회전 (Pillow의 `expand=True`로 전체 보존)
2. 내접 직사각형 크기 계산
3. 중앙에서 자동 크롭
4. 결과: 빈 공간 완전히 제거된 자연스러운 이미지

---

### 2. 원근 변형 후 빈 여백 처리

**문제 상황**

원근 변형(Perspective Transform)을 적용하면 이미지 가장자리에 흰색 여백이 생깁니다. 4개 점의 좌표만으로 변환 행렬을 계산하는데, 어느 정도 크롭해야 여백이 완전히 사라지는지가 명확하지 않았습니다.

**해결 과정**

처음에는 고정값(10px, 20px)으로 크롭했는데, 변형 강도에 따라 부족하거나 과하게 잘리는 문제가 있었습니다. 핸들 4개의 이동 거리 중 최댓값을 기준으로 크롭 마진을 동적으로 계산하도록 수정했습니다.

#### 구현 ([image_ops.py:297-303](app/core/image_ops.py#L297-L303))

```python
# 원근 변형 후 크롭 마진 계산
max_offset = max(
    abs(tl[0]), abs(tl[1]), abs(tr[0]), abs(tr[1]),
    abs(bl[0]), abs(bl[1]), abs(br[0]), abs(br[1])
)

margin = int(max_offset * 2) + 2  # 최대 오프셋의 2배 + 2px
crop_w = max(10, output_w - margin * 2)
crop_h = max(10, output_h - margin * 2)
```

**결과**

- 약한 변형: 최소한만 크롭 (이미지 손실 적음)
- 강한 변형: 충분히 크롭 (흰색 여백 완전 제거)
- 변형 강도와 무관하게 깔끔한 결과 보장

---

### 3. 이미지 포맷 선택: 기술 vs 사용자 경험

#### 문제 상황

처음에는 PNG 형식으로 이미지를 저장했는데, **용량이 너무 컸습니다**. 같은 이미지가 PNG는 2.4MB인데 다른 포맷은 훨씬 작았습니다.

#### 기술적으로 최적의 선택: WebP

여러 포맷을 비교 분석한 결과:

| 포맷      | 파일 크기 | 압축률       | 품질             | 호환성        |
| --------- | --------- | ------------ | ---------------- | ------------- |
| PNG       | 2.4MB     | -            | Perfect (무손실) | 완벽          |
| **WebP**  | **720KB** | **70% 감소** | Excellent        | 현대 브라우저 |
| JPEG Q=75 | 640KB     | 73% 감소     | Good             | 완벽          |

**WebP가 압도적으로 유리했습니다:**

- PNG 대비 **70% 이상 용량 감소**
- 무손실/손실 압축 모두 지원
- 현대적 포맷으로 품질도 우수
- 메타데이터 지원

당연히 WebP로 가는 게 맞다고 생각했고, 실제로 구현도 해봤습니다:

```python
# WebP 저장 시도
img.save(output_path, "WEBP", quality=80, exif=exif_bytes)
# 결과: 용량도 작고, 품질도 좋음
```

#### 실제 문제: Windows + Chrome 환경

그런데 **실제 사용자들(직원들)로부터 불편하다는 피드백**이 들어왔습니다.

**문제 상황:**

- Windows에서 WebP 파일을 더블클릭하면 → **웹브라우저(Chrome)로 열림**
- 이미지 뷰어가 뜰 거라고 기대했는데 갑자기 브라우저가 뜨니까 혼란스러움
- 이미지를 빠르게 확인하려고 클릭했는데 브라우저 로딩 기다려야 함
- 여러 이미지를 연속으로 보려면 매번 브라우저 탭이 열림
- 방향키로 다음 이미지 넘기기도 안 됨 (이미지 뷰어처럼)

**왜 이런 문제가?**

- Windows 10/11에서 WebP는 기본적으로 브라우저와 연결됨
- Windows 기본 "사진" 앱은 WebP를 지원하지만, 파일 연결이 브라우저 우선
- 일반 사용자들은 파일 연결 설정을 바꾸는 게 번거로움
- "왜 이미지인데 브라우저가 떠요?" 라는 질문이 계속 들어옴

#### 고민 과정: 기술 vs 사용성

기술적으로는 WebP가 명백히 우월한데, 실제 사용 환경에서는 불편함을 줍니다.

**고민했던 점:**

1. 이 프로그램을 쓰는 건 개발자가 아니라 일반 직원들
2. "포맷이 뭔지" 신경 쓰지 않고 그냥 더블클릭해서 이미지를 보고 싶어 함
3. 파일 용량보다 **익숙한 사용 경험**이 더 중요한가?
4. 기술적 우월성과 실용성 중 무엇을 선택해야 하는가?

#### 최종 결정: JPEG

**선택 이유:**

- PNG보다는 작고 (약 73% 감소)
- 모든 OS에서 기본 이미지 뷰어로 열림
- 품질도 충분함 (quality=75)
- 사용자가 전혀 신경 쓸 필요 없음

**트레이드오프 분석:**

| 항목        | WebP                | JPEG           | 결정 근거             |
| ----------- | ------------------- | -------------- | --------------------- |
| 파일 크기   | 720KB               | 640KB          | 큰 차이 없음 (80KB)   |
| 압축률      | 70%                 | 73%            | JPEG가 오히려 더 좋음 |
| 사용자 경험 | ⚠️ 브라우저 열림    | ✅ 뷰어로 열림 | **결정적 차이**       |
| 설정 필요   | 파일 연결 변경 필요 | 없음           | JPEG 승               |
| 호환성      | 신규 포맷           | 오래된 표준    | JPEG 승               |

#### JPEG 구현 상세

##### 1. RGBA → RGB 변환

JPEG는 투명도(Alpha 채널)를 지원하지 않으므로, RGBA 이미지를 흰색 배경으로 합성해야 합니다.

```python
def convert_to_rgb_for_jpeg(img: Image.Image) -> Image.Image:
    """JPEG 저장을 위해 RGBA/기타 모드를 RGB로 변환"""
    if img.mode == "RGBA":
        # 흰색 배경 생성
        background = Image.new("RGB", img.size, (255, 255, 255))

        # Alpha 채널을 마스크로 사용하여 합성
        # split()[3]은 RGBA의 A(알파) 채널
        background.paste(img, mask=img.split()[3])

        return background
    elif img.mode != "RGB":
        # CMYK, L(그레이스케일) 등 기타 모드도 RGB로 변환
        return img.convert("RGB")

    return img
```

**핵심 포인트:**

- `split()[3]`: RGBA의 네 번째 채널(Alpha)을 마스크로 추출
- `paste(..., mask=alpha)`: 알파값에 따라 투명도를 고려한 합성
- 투명 영역은 흰색(255, 255, 255)으로 대체

##### 2. EXIF 메타데이터 처리

PNG와 JPEG의 메타데이터 구조가 다르므로 별도 처리가 필요합니다.

```python
def save_as_jpeg_with_metadata(img: Image.Image, output_path: str, exif_dict: dict):
    """JPEG 저장 + EXIF 메타데이터 삽입"""
    # 1. RGB 변환
    img = convert_to_rgb_for_jpeg(img)

    # 2. EXIF 딕셔너리 → 바이너리 변환
    # PNG는 텍스트 청크를 사용하지만, JPEG는 EXIF 바이너리를 사용
    exif_bytes = piexif.dump(exif_dict)

    # 3. JPEG 저장
    img.save(
        output_path,
        "JPEG",
        quality=75,           # 압축 품질 (1-100)
        exif=exif_bytes,      # EXIF 메타데이터
        optimize=True,        # 추가 압축 최적화
        progressive=True      # 점진적 로딩 (웹 친화적)
    )
```

**PNG vs JPEG 메타데이터:**

| 항목                | PNG                     | JPEG            |
| ------------------- | ----------------------- | --------------- |
| 메타데이터 형식     | 텍스트 청크 (tEXt)      | EXIF 바이너리   |
| 저장 방식           | `pnginfo=PngInfo()`     | `exif=bytes`    |
| 생성 함수           | `create_png_metadata()` | `piexif.dump()` |
| Windows 탐색기 인식 | ⚠️ 부분 인식            | ✅ 완전 인식    |

##### 3. 최종 구현 ([commit b79c582](https://github.com))

```python
# metadata.py
def save_jpeg_with_metadata(img: Image.Image, filepath: str, overrides: dict):
    """JPEG 저장 + 랜덤 EXIF + 파일 타임스탬프 변경"""
    # EXIF 생성
    exif_dict = create_random_exif(overrides)

    # RGB 변환
    if img.mode == "RGBA":
        bg = Image.new("RGB", img.size, (255, 255, 255))
        bg.paste(img, mask=img.split()[3])
        img = bg
    elif img.mode != "RGB":
        img = img.convert("RGB")

    # JPEG 저장
    exif_bytes = piexif.dump(exif_dict)
    img.save(filepath, "JPEG", quality=75, exif=exif_bytes, optimize=True)

    # 파일 시스템 타임스탬프도 변경 (Windows 탐색기 표시용)
    if "DateTimeOriginal" in overrides:
        dt = datetime.strptime(overrides["DateTimeOriginal"], "%Y:%m:%d %H:%M:%S")
        timestamp = dt.timestamp()

        if platform.system() == "Windows":
            _set_windows_file_times(filepath, timestamp)
        else:
            os.utime(filepath, (timestamp, timestamp))
```

#### 결과 및 배운 점

**정량적 결과:**

- 파일 크기: PNG 대비 **73% 감소** (2.4MB → 640KB)
- WebP 대비: 약 80KB 작음 (오히려 JPEG가 더 작음)
- 사용자 불만: 100% 해결 (브라우저 문제 완전 제거)
- Windows 탐색기에서 EXIF 정보 정상 표시

**배운 점:**

처음엔 "WebP가 기술적으로 우월하니까 당연히 WebP"라고 생각했습니다.

하지만 실제 사용자들은 파일 포맷 같은 거에 관심 없습니다. 그냥 이미지를 빠르게 보고 싶을 뿐입니다. 더블클릭했는데 브라우저가 뜨면 "뭐지?" 하고 당황합니다.

**기술적 최적화보다 사용자가 익숙한 경험이 더 중요할 때가 있습니다.**

이 프로젝트의 목표는 "최신 이미지 포맷 사용하기"가 아니라 "이미지 일괄 처리를 편하게 하기"였습니다. JPEG를 선택한 건 타협이 아니라, **목표에 맞는 올바른 선택**이었습니다.

---

### 4. 멀티스레드 환경에서 JSON 파일 충돌

**문제 상황**

일괄 처리 중 변환 기록을 `transform_history.json`에 저장하는데, 여러 스레드가 동시에 파일을 읽고 쓰면서 `JSONDecodeError`가 발생했습니다. 파일이 깨지거나 앱이 크래시되는 경우도 있었습니다.

```python
# 문제가 있던 코드
def record_transform(filename, options):
    with open(HISTORY_FILE, "r") as f:
        history = json.load(f)  # 다른 스레드가 쓰는 중이면 깨진 JSON 읽음

    history[filename] = {...}

    with open(HISTORY_FILE, "w") as f:
        json.dump(history, f)  # 동시 쓰기로 파일 손상
```

**해결 방법**

`threading.Lock()`으로 파일 I/O를 동기화하고, 예외 처리를 추가했습니다.

#### 개선된 코드 ([transform_history.py:12-40](app/core/transform_history.py#L12-L40))

```python
import threading

_history_lock = threading.Lock()

def record_transform(filename: str, options: dict):
    with _history_lock:  # 한 번에 하나의 스레드만 접근
        try:
            history = _load_history()
        except (FileNotFoundError, json.JSONDecodeError):
            # 파일이 없거나 깨졌으면 빈 딕셔너리로 시작
            history = {}

        history[filename] = {
            "timestamp": datetime.now().isoformat(),
            "options": options
        }

        try:
            _save_history(history)
        except Exception as e:
            # 저장 실패해도 앱은 계속 실행 (사용자 경험 우선)
            print(f"Failed to save history: {e}")
```

**결과**

- 동시 쓰기로 인한 파일 손상 완전히 해결
- JSONDecodeError 발생 시에도 앱 크래시 없이 계속 실행
- 성능 저하: 무시할 수준 (Lock 대기 시간 `<`1ms)

---

## 성능 최적화

### 1. 썸네일 기반 미리보기

**문제 상황**

4K 이미지(3840x2160)에 변형을 적용하면 미리보기 생성에 800ms 이상 걸렸습니다. 슬라이더를 드래그할 때마다 UI가 멈추는 것처럼 느껴졌습니다.

**해결 방법**

미리보기는 512x512 썸네일로 축소해서 처리하고, 실제 저장할 때만 원본 해상도로 변환합니다.

#### 구현 ([preview.py:12-20](app/core/preview.py#L12-L20))

```python
def create_thumbnail(img: Image.Image, max_size: int = 512):
    w, h = img.size
    if w <= max_size and h <= max_size:
        return img.copy()

    ratio = min(max_size / w, max_size / h)
    new_w, new_h = int(w * ratio), int(h * ratio)

    return img.resize((new_w, new_h), Image.Resampling.LANCZOS)
```

**성능 개선 효과** (4K 이미지 기준)

| 항목               | Before (원본) | After (썸네일) | 개선율         |
| ------------------ | ------------- | -------------- | -------------- |
| 처리 픽셀 수       | 8,294,400     | 262,144        | **96.8% 감소** |
| 미리보기 생성 시간 | 800ms         | **95ms**       | **8.4배 빠름** |
| 메모리 사용량      | 24MB          | **768KB**      | **30배 감소**  |

**좌표 변환**

자유변형 핸들의 좌표는 썸네일 기준이므로, 실제 저장 시 원본 해상도로 변환해야 합니다.

```python
# 썸네일 → 원본 좌표 변환
scale_x = orig_w / thumb_w
scale_y = orig_h / thumb_h
full_corners = [(x * scale_x, y * scale_y) for x, y in preview_corners]
```

---

### 2. NumPy 벡터화로 노이즈 추가 고속화

**문제 상황**

처음에는 이중 for 문으로 픽셀을 하나씩 순회하면서 노이즈를 추가했는데, 2000x2000 이미지에 1.2초나 걸렸습니다.

```python
# Before: 이중 루프 (느림)
for y in range(h):
    for x in range(w):
        r, g, b = img.getpixel((x, y))
        noise_val = random.gauss(0, intensity)
        new_r = max(0, min(255, r + noise_val))
        # ... (b, g도 동일)
        img.putpixel((x, y), (new_r, new_g, new_b))
```

**해결 방법**

NumPy 배열 연산으로 벡터화했습니다. CPU의 SIMD 명령어를 자동으로 활용해서 병렬 처리됩니다.

#### 개선된 코드 ([image_ops.py:180-188](app/core/image_ops.py#L180-L188))

```python
def add_noise(img: Image.Image, intensity: float):
    arr = np.array(img, dtype=np.float32)  # 한 번에 변환
    noise = np.random.normal(0, intensity, arr.shape)  # 벡터화된 정규분포
    noisy = np.clip(arr + noise, 0, 255).astype(np.uint8)  # 배열 덧셈 + 클리핑
    return Image.fromarray(noisy)
```

**성능 비교** (2000x2000 이미지)

| 방식         | 소요 시간 | 개선율          |
| ------------ | --------- | --------------- |
| 이중 for 문  | 1200ms    | -               |
| NumPy 벡터화 | **45ms**  | **26.7배 빠름** |

---

### 3. QThreadPool로 일괄 처리 병렬화

**구현**

100개 파일을 처리할 때 CPU 코어 개수만큼 자동으로 병렬화합니다.

```python
# main_window.py:44-127
class TransformWorker(QRunnable):
    def run(self):
        img = Image.open(self.filepath)
        result = apply_transforms(img, self.options)
        result.save(output_path, "JPEG", quality=75)
        self.signals.finished.emit()

# 메인 윈도우에서
pool = QThreadPool.globalInstance()
for filepath in file_list:
    worker = TransformWorker(filepath, options)
    pool.start(worker)  # 자동으로 스레드 풀 관리
```

**성능 개선** (100개 파일, 4코어 CPU)

- 싱글스레드: 82초
- 멀티스레드: **25.6초** (3.2배 개선)

---

## 트러블슈팅 사례

### 1. QImage 메모리 참조 문제

**문제 상황**

미리보기 이미지를 Pillow에서 QPixmap으로 변환할 때 가끔 segmentation fault가 발생했습니다.

```python
# 문제가 있던 코드
data = img.tobytes()
qimage = QImage(data, w, h, format)
return QPixmap.fromImage(qimage)  # data가 GC되면 크래시
```

**원인**

`QImage`는 바이트 데이터를 복사하지 않고 참조만 합니다. Python의 GC가 `data`를 해제하면 `QImage`가 해제된 메모리를 가리키게 되어 segfault가 발생합니다.

**해결 방법** ([preview.py:23-35](app/core/preview.py#L23-L35))

```python
def pil_to_qpixmap(img: Image.Image):
    data = img.tobytes("raw", img.mode)
    qimage = QImage(data, w, h, bytes_per_line, qformat)
    return QPixmap.fromImage(qimage.copy())  # .copy()로 내부 복사
```

`.copy()`를 호출하면 QPixmap 변환 시 픽셀 데이터가 Qt 내부로 복사되어 Python GC와 독립적으로 관리됩니다.

---

### 2. Windows/macOS 파일 타임스탬프 차이

**문제 상황**

EXIF의 `DateTimeOriginal`을 변경해도 Windows 탐색기에서는 "만든 날짜"가 현재 시각으로 표시됐습니다. macOS Finder에서는 정상 작동했습니다.

**원인**

- **Windows**: 파일 시스템 레벨의 "만든 날짜"를 우선 표시 (EXIF는 무시)
- **macOS**: EXIF를 읽어서 "만든 날짜"로 표시

**해결 방법**

Windows에서는 ctypes로 Win32 API를 직접 호출해서 파일 시스템 타임스탬프를 변경합니다.

#### 구현 ([metadata.py:223-280](app/core/metadata.py#L223-L280))

```python
def _set_windows_file_times(filepath: str, timestamp: float):
    import ctypes
    from ctypes import wintypes

    kernel32 = ctypes.windll.kernel32

    # 파일 핸들 열기
    handle = kernel32.CreateFileW(
        filepath, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
        None, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, None
    )

    # Unix timestamp → Windows FILETIME 변환
    # (1970-01-01 → 1601-01-01 기준으로 변환, 100ns 단위)
    EPOCH_DIFF = 116444736000000000
    ft_value = int((timestamp * 10000000) + EPOCH_DIFF)

    filetime = FILETIME()
    filetime.dwLowDateTime = ft_value & 0xFFFFFFFF
    filetime.dwHighDateTime = (ft_value >> 32) & 0xFFFFFFFF

    # 만든 날짜, 접근 날짜, 수정 날짜 모두 설정
    kernel32.SetFileTime(handle, ctypes.byref(filetime),
                         ctypes.byref(filetime), ctypes.byref(filetime))
    kernel32.CloseHandle(handle)

# 플랫폼별 분기
if platform.system() == "Windows":
    _set_windows_file_times(filepath, timestamp)
else:
    os.utime(filepath, (timestamp, timestamp))  # macOS/Linux
```

**결과**

Windows 탐색기와 macOS Finder 모두에서 "만든 날짜"가 정확하게 표시됩니다.

---

### 3. 원근 변형 시 특이 행렬 문제

**문제 상황**

4개 핸들이 거의 일직선상에 있을 때 `np.linalg.LinAlgError: Singular matrix` 에러가 발생합니다.

```python
# 역행렬이 존재하지 않는 경우
coeff = np.linalg.inv(A.T @ A) @ A.T @ B  # 특이 행렬이면 에러
```

**현재 상태**

예외 처리가 미비해서 앱이 크래시될 수 있습니다. `IMPROVEMENTS.md`에 개선 계획으로 기록해뒀습니다.

**향후 개선 방안**

1. UI 레벨에서 핸들 위치 제약 (최소 거리 유지)
2. 외적으로 일직선 검증 후 경고 표시
3. Try-except로 실패 시 원본 반환

---

## 아키텍처 설계 결정

### 계층 분리 (UI와 Core)

```
/app
├── /ui          # PySide6 GUI (Signal/Slot 패턴)
└── /core        # 비즈니스 로직 (이미지 처리, 메타데이터)
```

**선택 근거**

- UI 프레임워크를 바꿔도 Core는 재사용 가능 (CLI 버전 제작 가능)
- 테스트 용이: Core 로직은 GUI 없이 단위 테스트 가능
- 단일 책임 원칙: 각 모듈이 명확한 역할

---

## 기술적 학습 및 성장

### 1. 선형대수 실무 적용

대학교 때 배운 행렬 연산이 실제로 쓰일 줄 몰랐는데, 원근 변형 구현하면서 호모그래피 행렬 계산을 직접 해봤습니다. NumPy의 행렬 연산이 생각보다 직관적이었습니다.

### 2. 멀티스레딩 동기화

Lock 없이 멀티스레드를 구현했다가 JSON 파일이 깨지는 버그를 겪었습니다. 동시성 문제는 재현이 어렵고 디버깅도 까다롭다는 걸 체감했습니다. `threading.Lock()`으로 해결하고 나니 안정성이 확 올라갔습니다.

### 3. 플랫폼별 분기 처리

Windows API를 ctypes로 직접 호출하는 게 처음에는 어려웠는데, MSDN 문서를 보면서 구조체 정의하고 함수 호출하는 과정이 재밌었습니다. 같은 기능이 OS마다 다르게 구현되어 있다는 걸 알게 됐습니다.

---

## 향후 개선 계획

1. **특이 행렬 예외 처리**: 원근 변형 시 일직선 검증 로직 추가
2. **설정 프리셋**: 자주 쓰는 옵션 조합 저장/불러오기
3. **배치 파일명 규칙**: 파일명에 타임스탬프 또는 시퀀스 번호 추가 옵션
4. **Undo/Redo**: 변환 이력 기반 되돌리기 기능

---

## 성과 지표

- **파일 크기 최적화**: PNG 대비 73% 감소 (JPEG Q=75)
- **미리보기 속도**: 8.4배 개선 (썸네일 기반)
- **노이즈 추가**: 26.7배 고속화 (NumPy 벡터화)
- **일괄 처리**: 3.2배 빠름 (멀티스레딩, 4코어 기준)
- **메모리 사용**: 96.8% 감소 (썸네일 미리보기)

---

## 마무리

처음에는 단순히 "메타데이터 지우는 프로그램"을 만들려고 했는데, 회전 후 크롭, 원근 변형, 멀티스레딩 등 생각보다 복잡한 문제들을 많이 마주쳤습니다. 특히 수학적 알고리즘(내접 직사각형, 행렬 변환)을 직접 구현하면서, 단순히 라이브러리를 가져다 쓰는 것보다 훨씬 깊이 있게 이해할 수 있었습니다.

Windows/macOS 플랫폼 차이, 멀티스레드 동기화, 메모리 최적화 등 실무에서 자주 마주칠 문제들을 경험한 게 가장 큰 수확이라고 생각합니다.
